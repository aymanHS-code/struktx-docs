---
title: "Middleware"
description: "Learn how to use and create middleware for pre/post processing in StruktX"
---

<Info>
  Middleware in StruktX allows you to intercept and modify the request flow at different stages. This is useful for logging, authentication, rate limiting, and other cross-cutting concerns.
</Info>

## Overview

Middleware components implement optional hooks that are called at specific points in the request lifecycle:

<Steps>
  <Step title="before_classify">
    Called before query classification
  </Step>
  <Step title="after_classify">
    Called after query classification
  </Step>
  <Step title="before_handle">
    Called before handler execution
  </Step>
  <Step title="after_handle">
    Called after handler execution
  </Step>
</Steps>

## Basic Middleware Example

```python
from strukt.middleware import Middleware
from strukt.types import InvocationState

class ComprehensiveMiddleware(Middleware):
    def before_classify(self, state: InvocationState) -> InvocationState:
        """Called before query classification"""
        print(f"🔍 Classifying: {state.text}")
        # You can modify the state here
        state.metadata["pre_classify_time"] = "2024-01-01T12:00:00Z"
        return state
    
    def after_classify(self, state: InvocationState) -> InvocationState:
        """Called after query classification"""
        print(f"✅ Classified as: {state.metadata.get('classification', 'unknown')}")
        return state
    
    def before_handle(self, state: InvocationState) -> InvocationState:
        """Called before handler execution"""
        print(f"🔄 Handling with: {state.metadata.get('handler_type', 'unknown')}")
        return state
    
    def after_handle(self, state: InvocationState) -> InvocationState:
        """Called after handler execution"""
        print(f"🎯 Response: {state.metadata.get('response', 'no response')}")
        return state
```

## Configuration

Add middleware to your application configuration:

```python
from strukt import create, StruktConfig, HandlersConfig, LLMClientConfig, MemoryConfig
from strukt.middleware import MiddlewareConfig
from strukt.examples.time_handler import TimeHandler

app = create(StruktConfig(
    llm=LLMClientConfig("langchain_openai:ChatOpenAI", dict(model="gpt-4o-mini")),
    classifier=ClassifierConfig(DefaultLLMClassifier,
                             dict(max_parts=4,
                             allowed_types=["time_service", "general", "memory_extraction"])),
    handlers=HandlersConfig(
        registry=dict(time_service=TimeHandler),
        default_route="general",
    ),
    middleware=[
        MiddlewareConfig("your.own.middleware:ComprehensiveMiddleware"),  # custom middleware
        MiddlewareConfig("strukt.examples.middleware:LoggingMiddleware", dict(verbose=True)),  # packaged middleware
    ],
))
```

### MiddlewareConfig (new)

```python
from strukt.middleware import MiddlewareConfig

# Factory can be a callable or an import string "module:attr"; params are optional
MiddlewareConfig(
  factory="strukt.examples.middleware:MemoryExtractionMiddleware",
  params={"max_items": 5}
)
```

## Built-in Middleware

### Logging Middleware

```python
from strukt.examples.middleware import LoggingMiddleware

# Basic logging
middleware=[MiddlewareConfig("strukt.examples.middleware:LoggingMiddleware")]

# Verbose logging
middleware=[MiddlewareConfig("strukt.examples.middleware:LoggingMiddleware", params={"verbose": True})]

# Custom log file
middleware=[MiddlewareConfig("strukt.examples.middleware:LoggingMiddleware", params={"log_file": "app.log"})]
```

### Memory Extraction Middleware

```python
from strukt import StruktConfig, MemoryConfig
from strukt.middleware import MiddlewareConfig

config = StruktConfig(
  memory=MemoryConfig(
    factory="strukt.memory:UpstashVectorMemoryEngine",
    params={"index_url": "...", "index_token": "...", "namespace": "app1"},
    use_store=True,
    augment_llm=True,
  ),
  middleware=[
    MiddlewareConfig("strukt.examples.middleware:MemoryExtractionMiddleware"),
  ]
)
```

### Logging Middleware

```python
import logging
from datetime import datetime
from strukt.middleware import Middleware
from strukt.types import InvocationState

class LoggingMiddleware(Middleware):
    def __init__(self, log_file: str = "strukt.log"):
        self.log_file = log_file
        self.logger = logging.getLogger(__name__)
    
    def before_classify(self, state: InvocationState) -> InvocationState:
        with open(self.log_file, "a") as f:
            f.write(f"[{datetime.now()}] Classifying: {state.text}\n")
        return state
    
    def after_handle(self, state: InvocationState) -> InvocationState:
        with open(self.log_file, "a") as f:
            f.write(f"[{datetime.now()}] Response: {state.metadata.get('response', 'no response')}\n")
        return state
```

### Rate Limiting Middleware

```python
import time
from collections import defaultdict
from strukt.middleware import Middleware
from strukt.types import InvocationState

class RateLimitMiddleware(Middleware):
    def __init__(self, max_requests: int = 10, window_seconds: int = 60):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
        self.requests = defaultdict(list)
    
    def before_classify(self, state: InvocationState) -> InvocationState:
        user_id = state.context.get("user_id", "anonymous")
        now = time.time()
        
        # Clean old requests
        self.requests[user_id] = [req for req in self.requests[user_id] 
                                if now - req < self.window_seconds]
        
        # Check rate limit
        if len(self.requests[user_id]) >= self.max_requests:
            raise Exception(f"Rate limit exceeded for user {user_id}")
        
        # Add current request
        self.requests[user_id].append(now)
        return state
```

### Authentication Middleware

```python
from strukt.middleware import Middleware
from strukt.types import InvocationState

class AuthMiddleware(Middleware):
    def __init__(self, valid_tokens: set):
        self.valid_tokens = valid_tokens
    
    def before_classify(self, state: InvocationState) -> InvocationState:
        token = state.context.get("auth_token")
        if not token or token not in self.valid_tokens:
            raise Exception("Invalid authentication token")
        return state
```

### Metrics Middleware

```python
import time
from strukt.middleware import Middleware
from strukt.types import InvocationState

class MetricsMiddleware(Middleware):
    def __init__(self):
        self.metrics = {
            "total_requests": 0,
            "classification_times": [],
            "handler_times": [],
        }
    
    def before_classify(self, state: InvocationState) -> InvocationState:
        self.metrics["total_requests"] += 1
        state.metadata["classify_start"] = time.time()
        return state
    
    def after_classify(self, state: InvocationState) -> InvocationState:
        if "classify_start" in state.metadata:
            duration = time.time() - state.metadata["classify_start"]
            self.metrics["classification_times"].append(duration)
        return state
    
    def before_handle(self, state: InvocationState) -> InvocationState:
        state.metadata["handle_start"] = time.time()
        return state
    
    def after_handle(self, state: InvocationState) -> InvocationState:
        if "handle_start" in state.metadata:
            duration = time.time() - state.metadata["handle_start"]
            self.metrics["handler_times"].append(duration)
        return state
    
    def get_metrics(self):
        return {
            "total_requests": self.metrics["total_requests"],
            "avg_classification_time": sum(self.metrics["classification_times"]) / len(self.metrics["classification_times"]) if self.metrics["classification_times"] else 0,
            "avg_handler_time": sum(self.metrics["handler_times"]) / len(self.metrics["handler_times"]) if self.metrics["handler_times"] else 0,
        }
```

### Context Enrichment Middleware

```python
from strukt.middleware import Middleware
from strukt.types import InvocationState

class ContextEnrichmentMiddleware(Middleware):
    def __init__(self, enrichments: dict):
        self.enrichments = enrichments
    
    def before_classify(self, state: InvocationState) -> InvocationState:
        # Add static context
        for key, value in self.enrichments.items():
            if key not in state.context:
                state.context[key] = value
        
        # Add dynamic context
        state.context["timestamp"] = "2024-01-01T12:00:00Z"
        state.context["request_id"] = f"req_{hash(state.text) % 10000}"
        
        return state
```

## Middleware Best Practices

<Steps>
  <Step title="Keep it Simple">
    Each middleware should have a single responsibility
  </Step>
  <Step title="Handle Errors">
    Implement proper error handling in your middleware
  </Step>
  <Step title="Preserve State">
    Always return the modified state from middleware hooks
  </Step>
  <Step title="Use Metadata">
    Store additional information in state.metadata for cross-middleware communication
  </Step>
  <Step title="Performance">
    Keep middleware lightweight to avoid impacting response times
  </Step>
</Steps>

## Middleware Order

Middleware is executed in the order specified in the configuration:

```python
middleware=[
  MiddlewareConfig("your.own.middleware:AuthMiddleware", params={"valid_tokens": {"token1"}}),
  MiddlewareConfig("your.own.middleware:RateLimitMiddleware", params={"max_requests": 10}),
  MiddlewareConfig("strukt.examples.middleware:LoggingMiddleware", params={"verbose": True}),
  MiddlewareConfig("your.own.middleware:MetricsMiddleware"),
]
```

<Note>
  The order matters\! Authentication and rate limiting should typically come before logging and metrics.
</Note>

## Error Handling

Middleware can raise exceptions to stop request processing:

```python
class ValidationMiddleware(Middleware):
    def before_classify(self, state: InvocationState) -> InvocationState:
        if not state.text.strip():
            raise ValueError("Empty input not allowed")
        
        if len(state.text) > 1000:
            raise ValueError("Input too long (max 1000 characters)")
        
        return state
```

<Info>
  Middleware is a powerful feature for adding cross-cutting concerns to your StruktX application. Use it to implement logging, authentication, rate limiting, and other infrastructure concerns.
</Info>