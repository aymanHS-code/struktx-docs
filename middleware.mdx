---
title: "Middleware"
description: "Learn how to use and create middleware for pre/post processing in StruktX"
---

Middleware in StruktX allows you to intercept and modify the request flow at different stages. This is useful for logging, authentication, rate limiting, and other cross-cutting concerns.

## Overview

Middleware components implement optional hooks that are called at specific points in the request lifecycle:

<Steps>
  <Step title="before_classify">
    Called before query classification
  </Step>
  <Step title="after_classify">
    Called after query classification
  </Step>
  <Step title="before_handle">
    Called before handler execution
  </Step>
  <Step title="after_handle">
    Called after handler execution
  </Step>
</Steps>

## Basic Middleware Example

```python
from strukt.middleware import Middleware
from strukt.types import InvocationState

class ComprehensiveMiddleware(Middleware):
    def before_classify(self, state: InvocationState) -> InvocationState:
        """Called before query classification"""
        print(f"ðŸ” Classifying: {state.text}")
        # You can modify the state here
        state.metadata["pre_classify_time"] = "2024-01-01T12:00:00Z"
        return state
    
    def after_classify(self, state: InvocationState) -> InvocationState:
        """Called after query classification"""
        print(f"âœ… Classified as: {state.metadata.get('classification', 'unknown')}")
        return state
    
    def before_handle(self, state: InvocationState) -> InvocationState:
        """Called before handler execution"""
        print(f"ðŸ”„ Handling with: {state.metadata.get('handler_type', 'unknown')}")
        return state
    
    def after_handle(self, state: InvocationState) -> InvocationState:
        """Called after handler execution"""
        print(f"ðŸŽ¯ Response: {state.metadata.get('response', 'no response')}")
        return state
```

## Configuration

Add middleware to your application configuration:

```python
from strukt import create, StruktConfig, HandlersConfig, LLMClientConfig
from strukt.examples.simple_classifier import SimpleKeywordClassifier
from strukt.examples.time_handler import TimeHandler

app = create(StruktConfig(
    llm=LLMClientConfig(factory=lambda **_: MockLLM()),
    classifier=dict(factory=lambda **_: SimpleKeywordClassifier()),
    handlers=HandlersConfig(
        registry={
            "time_service": lambda llm, **_: TimeHandler(llm),
        },
        default_route="general",
    ),
    middleware=[
        lambda **_: ComprehensiveMiddleware(),  # custom middleware
        lambda **_: LoggingMiddleware(verbose=True),  # packaged middleware
    ],
))
```

## Built-in Middleware

### Logging Middleware

```python
from strukt.examples.middleware import LoggingMiddleware

# Basic logging
middleware=[lambda **_: LoggingMiddleware()]

# Verbose logging
middleware=[lambda **_: LoggingMiddleware(verbose=True)]

# Custom log file
middleware=[lambda **_: LoggingMiddleware(log_file="app.log")]
```

### Approval Middleware

```python
from strukt.examples.middleware import ApprovalMiddleware

# Content filtering
middleware=[
    lambda **_: ApprovalMiddleware(
        rule=lambda state, qtype, parts: "delete" not in state.text.lower()
    )
]

# Custom approval logic
def custom_approval_rule(state, qtype, parts):
    # Check if user has permission for this query type
    user_role = state.context.get("user_role", "user")
    if qtype == "admin_service" and user_role != "admin":
        return False
    return True

middleware=[
    lambda **_: ApprovalMiddleware(rule=custom_approval_rule)
]
```

## Custom Middleware Examples

### Logging Middleware

```python
import logging
from datetime import datetime
from strukt.middleware import Middleware
from strukt.types import InvocationState

class LoggingMiddleware(Middleware):
    def __init__(self, log_file: str = "strukt.log"):
        self.log_file = log_file
        self.logger = logging.getLogger(__name__)
    
    def before_classify(self, state: InvocationState) -> InvocationState:
        with open(self.log_file, "a") as f:
            f.write(f"[{datetime.now()}] Classifying: {state.text}\n")
        return state
    
    def after_handle(self, state: InvocationState) -> InvocationState:
        with open(self.log_file, "a") as f:
            f.write(f"[{datetime.now()}] Response: {state.metadata.get('response', 'no response')}\n")
        return state
```

### Rate Limiting Middleware

```python
import time
from collections import defaultdict
from strukt.middleware import Middleware
from strukt.types import InvocationState

class RateLimitMiddleware(Middleware):
    def __init__(self, max_requests: int = 10, window_seconds: int = 60):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
        self.requests = defaultdict(list)
    
    def before_classify(self, state: InvocationState) -> InvocationState:
        user_id = state.context.get("user_id", "anonymous")
        now = time.time()
        
        # Clean old requests
        self.requests[user_id] = [req for req in self.requests[user_id] 
                                if now - req < self.window_seconds]
        
        # Check rate limit
        if len(self.requests[user_id]) >= self.max_requests:
            raise Exception(f"Rate limit exceeded for user {user_id}")
        
        # Add current request
        self.requests[user_id].append(now)
        return state
```

### Authentication Middleware

```python
from strukt.middleware import Middleware
from strukt.types import InvocationState

class AuthMiddleware(Middleware):
    def __init__(self, valid_tokens: set):
        self.valid_tokens = valid_tokens
    
    def before_classify(self, state: InvocationState) -> InvocationState:
        token = state.context.get("auth_token")
        if not token or token not in self.valid_tokens:
            raise Exception("Invalid authentication token")
        return state
```

### Metrics Middleware

```python
import time
from strukt.middleware import Middleware
from strukt.types import InvocationState

class MetricsMiddleware(Middleware):
    def __init__(self):
        self.metrics = {
            "total_requests": 0,
            "classification_times": [],
            "handler_times": [],
        }
    
    def before_classify(self, state: InvocationState) -> InvocationState:
        self.metrics["total_requests"] += 1
        state.metadata["classify_start"] = time.time()
        return state
    
    def after_classify(self, state: InvocationState) -> InvocationState:
        if "classify_start" in state.metadata:
            duration = time.time() - state.metadata["classify_start"]
            self.metrics["classification_times"].append(duration)
        return state
    
    def before_handle(self, state: InvocationState) -> InvocationState:
        state.metadata["handle_start"] = time.time()
        return state
    
    def after_handle(self, state: InvocationState) -> InvocationState:
        if "handle_start" in state.metadata:
            duration = time.time() - state.metadata["handle_start"]
            self.metrics["handler_times"].append(duration)
        return state
    
    def get_metrics(self):
        return {
            "total_requests": self.metrics["total_requests"],
            "avg_classification_time": sum(self.metrics["classification_times"]) / len(self.metrics["classification_times"]) if self.metrics["classification_times"] else 0,
            "avg_handler_time": sum(self.metrics["handler_times"]) / len(self.metrics["handler_times"]) if self.metrics["handler_times"] else 0,
        }
```

### Context Enrichment Middleware

```python
from strukt.middleware import Middleware
from strukt.types import InvocationState

class ContextEnrichmentMiddleware(Middleware):
    def __init__(self, enrichments: dict):
        self.enrichments = enrichments
    
    def before_classify(self, state: InvocationState) -> InvocationState:
        # Add static context
        for key, value in self.enrichments.items():
            if key not in state.context:
                state.context[key] = value
        
        # Add dynamic context
        state.context["timestamp"] = "2024-01-01T12:00:00Z"
        state.context["request_id"] = f"req_{hash(state.text) % 10000}"
        
        return state
```

## Middleware Best Practices

<Steps>
  <Step title="Keep it Simple">
    Each middleware should have a single responsibility
  </Step>
  <Step title="Handle Errors">
    Implement proper error handling in your middleware
  </Step>
  <Step title="Preserve State">
    Always return the modified state from middleware hooks
  </Step>
  <Step title="Use Metadata">
    Store additional information in state.metadata for cross-middleware communication
  </Step>
  <Step title="Performance">
    Keep middleware lightweight to avoid impacting response times
  </Step>
</Steps>

## Middleware Order

Middleware is executed in the order specified in the configuration:

```python
middleware=[
    lambda **_: AuthMiddleware(valid_tokens={"token1"}),      # 1st
    lambda **_: RateLimitMiddleware(max_requests=10),         # 2nd
    lambda **_: LoggingMiddleware(verbose=True),              # 3rd
    lambda **_: MetricsMiddleware(),                          # 4th
]
```

<Note>
  The order matters\! Authentication and rate limiting should typically come before logging and metrics.
</Note>

## Error Handling

Middleware can raise exceptions to stop request processing:

```python
class ValidationMiddleware(Middleware):
    def before_classify(self, state: InvocationState) -> InvocationState:
        if not state.text.strip():
            raise ValueError("Empty input not allowed")
        
        if len(state.text) > 1000:
            raise ValueError("Input too long (max 1000 characters)")
        
        return state
```

<Info>
  Middleware is a powerful feature for adding cross-cutting concerns to your StruktX application. Use it to implement logging, authentication, rate limiting, and other infrastructure concerns.
</Info>